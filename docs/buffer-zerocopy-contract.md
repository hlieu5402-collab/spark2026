# 缓冲零拷贝契约（BufView & ReadableBuffer）

## 目标
- 在 `spark-core` 内形成统一的零拷贝语义，支撑 TCK 对缓冲行为的断言。
- 指导第三方实现（如自研缓冲池、共享内存通道）在接入框架时遵循一致的生命周期与不可变约束。

## 关键术语
- **零拷贝 (Zero-copy)**：视图暴露的 `&[u8]` 与底层存储共享同一段内存地址，期间不允许复制字节内容。
- **视图 (BufView)**：通过借用 `&self` 生成的只读窗口，调用方仅能读取数据，不能修改或延长生命周期。
- **分片 (Chunk)**：`BufView::as_chunks` 迭代器返回的单个切片，每个切片可以视为 scatter/gather IO 的一段。

## 契约条款
1. **零复制**
   - `BufView::as_chunks` 返回的每个 `&[u8]` 必须直接指向底层缓冲，禁止临时 `Vec`/`Box` 克隆字节。
   - 若实现者需要压缩分片或重新组织内存，必须在暴露视图前完成；视图生命周期内不允许再进行写入或搬移。
2. **不可变性**
   - 视图生命周期内（即迭代器被消费完之前）不得对底层缓冲执行写入、释放或缩容操作。
   - 若内部实现依赖引用计数或写时复制（COW），必须确保视图期间保持共享/冻结状态。
3. **生命周期**
   - 所有分片切片的生命周期至少与 `&self` 等长。通过 `BufView` 返回的引用不得悬垂，也不得跨越原对象被丢弃的时刻。
   - `ReadableBuffer::split_to` 等会改变所有权的方法在视图存在时不得被并发调用，以免打破借用规则。
4. **长度一致性**
   - `BufView::len()` 必须等于 `as_chunks()` 全部切片长度之和。
   - `BufView::chunk_count()` 仅用于诊断，不得被实现者用于惰性补足；返回值应真实反映当前逻辑分片数量。
5. **失败语义**
   - 若无法满足零拷贝（例如底层硬件仅提供 DMA 缓冲转存），实现者应显式复制并在文档中标明，此时视为违反契约，需要在 TCK 中豁免。

## 违规定义
- **显式复制**：`BufView::as_chunks` 内部触发 `memcpy`/`to_vec`/`clone` 等复制操作。
- **隐式复制**：分片返回引用失效，调用方被迫重新申请缓冲或降级为 `ReadableBuffer::copy_into_slice`。
- **数据漂移**：迭代过程中缓冲内容被修改或缩容，导致相同分片在不同阶段指向不同数据。

发现以上任何情况，均应视为违反零拷贝契约，需要通过 TCK 报告并阻断发布。

## 推荐实践
- 在暴露视图前执行“冻结”操作（如 Tokio `Bytes::freeze`），确保引用稳定。
- 若使用分段链表/环形缓冲，建议实现内部指针压缩（coalesce）后再返回视图，以减少分片数量。
- 在单元测试中记录 `Chunks::total_len()` 与 `BufView::len()`，并结合指针比较 (e.g. `ptr::eq`) 验证零拷贝。
