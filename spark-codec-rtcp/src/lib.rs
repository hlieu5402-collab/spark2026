#![cfg_attr(not(feature = "std"), no_std)]
#![warn(missing_docs)]

//! # spark-codec-rtcp
//!
//! ## 教案目的（Why）
//! - **定位**：Real-time Transport Control Protocol (RTCP) 控制平面的编解码骨架，负责媒体质量反馈与会话控制消息。
//! - **架构角色**：与 RTP 数据面配对，提供统计、拥塞控制和同步信息，保障实时会话体验。
//! - **设计策略**：先行创建占位模块与依赖关系，确保在工作区内具备统一的命名与测试入口。
//!
//! ## 交互契约（What）
//! - **依赖输入**：依托 `spark-core` 的 Codec trait，将处理从网络接收的 RTCP 包或生成反馈消息。
//! - **输出职责**：后续会暴露用于构建 SR、RR、SDES、BYE 等报文的接口；当前仅保留结构占位。
//! - **前置约束**：运行环境需具备与 RTP 相同的时钟/缓冲支持；占位阶段不做任何资源申请。
//!
//! ## 实现策略（How）
//! - **实施步骤**：
//!   1. 通过 `RtcpCodecScaffold` 固定 API 入口；
//!   2. 在 `spark-impl-tck` 中引入控制面测试用例，覆盖丢包统计、抖动估计等逻辑；
//!   3. 待实现阶段将结合 `spark-core` 的错误模型提供详细诊断。
//! - **技术考量**：沿用零尺寸结构，避免提前绑定内部状态；保留 `compat_v0` feature 以便未来做兼容层。
//!
//! ## 风险提示（Trade-offs）
//! - **功能缺口**：尚未实现任何统计或反馈逻辑，当前仅用于建立依赖。
//! - **演进风险**：控制报文格式复杂，后续扩展需严谨验证字段长度与对齐。
//! - **维护建议**：新增报文类型时务必同步更新测试与文档，防止协议偏差。

/// RTCP 编解码占位结构，约定控制平面实现入口。
///
/// ### 设计意图（Why）
/// - 让调用方可以立即引用 RTCP 模块，提前规划依赖结构。
/// - 与 RTP/SIP/SDP 形成完整的实时通讯协议栈。
///
/// ### 契约描述（What）
/// - 结构体当前不包含任何状态，纯粹作为类型锚点。
/// - 后续将扩展统计窗口、时钟同步参数等字段。
///
/// ### 实现细节（How）
/// - 维持零尺寸类型，结合 `Default`/`Copy` 简化测试注入。
/// - `const fn` 构造器保证可在静态上下文中创建实例。
///
/// ### 风险提示（Trade-offs）
/// - 随着控制逻辑复杂化，可能需要拆分为多个组件或引入内部引用计数。
#[derive(Debug, Default, Clone, Copy)]
pub struct RtcpCodecScaffold;

impl RtcpCodecScaffold {
    /// 构造 RTCP 编解码占位实例。
    ///
    /// ### 设计动机（Why）
    /// - 为 `spark-impl-tck` 即将添加的控制面测试准备构造入口。
    /// - 统一向调用方暴露实例化方法，减少后续 breaking change 的概率。
    ///
    /// ### 契约定义（What）
    /// - **输入**：无。
    /// - **输出**：返回 `RtcpCodecScaffold`，代表一个可用的占位对象。
    /// - **前置条件**：仅需完成编译期链接，无运行时依赖。
    /// - **后置条件**：调用方持有一个可复制的标记类型，可用于占位实现或泛型约束。
    ///
    /// ### 实现说明（How）
    /// - 选择 `const fn` 提升可用性，在常量上下文或静态变量中均可使用。
    ///
    /// ### 风险提示（Trade-offs）
    /// - 若未来构造函数需要校验参数，请将返回类型调整为 `Result` 并补充错误语义。
    #[must_use]
    pub const fn new() -> Self {
        Self
    }
}
