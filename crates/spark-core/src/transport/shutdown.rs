//! 半关闭方向语义的统一定义。
//!
//! # 教案级注释
//! - **定位（Why）**
//!   - TCP、QUIC 等传输协议都支持“半关闭”操作：调用方仅停止读或写方向，以实现半双工收尾或优雅退场。
//!   - 过往各传输 crate 各自定义枚举，导致上层业务要为不同协议写重复的匹配逻辑。
//!   - 将抽象上移到 `spark-core` 后，所有实现仅需复用同一语义，可集中约束文档与测试。
//! - **协作方式（How）**
//!   - 该模块仅暴露一个枚举 [`ShutdownDirection`]，配合 `transport` 模块中的连接/监听接口使用。
//!   - 具体传输实现（例如 `spark-transport-tcp`、`spark-transport-quic`）在执行半关闭时匹配该枚举，以协议特定 API 完成操作。
//!   - 若某协议不支持半关闭，可在实现层将 `Both` 分支映射为全关闭或返回自定义错误。
//! - **契约说明（What）**
//!   - 输入：调用方在发起关闭前必须根据业务约定选择枚举变体；不存在默认值，必须显式传递。
//!   - 输出：类型本身不携带副作用，仅作为意图描述，所有副作用由协议实现承担。
//! - **权衡与风险（Trade-offs）**
//!   - 统一抽象牺牲了一定的协议细节（例如某些协议区分优雅/强制关闭），但换取 API 的一致性。
//!   - 调用方需要了解：部分底层实现可能将 `Both` 解释为顺序的“先写后读”关闭；若需要更精细控制，请在协议层扩展额外 API。
//!
//! ## 互操作提示
//! - 当类型用于 `std` 世界时，可通过 `From<ShutdownDirection>` 为标准库的 `std::net::Shutdown` 实现转换（见 TCP 模块示例）。
//! - 在 `no_std` 环境下，该类型可直接被 `alloc` 工程使用，不依赖任何运行时能力。

/// 表示优雅关闭时需要停止的半双工方向。
///
/// ### 契约速览
/// - **输入参数（R3.1）**：由上层调用方显式传入枚举变体。
/// - **前置条件（R3.2）**：调用方已确保连接句柄处于活动状态，且协议实现支持对应的半关闭语义。
/// - **后置条件（R3.3）**：协议实现会根据该枚举完成半关闭；若协议不支持，将返回自定义错误或执行全关闭。
///
/// ### 使用范式（How）
/// 1. 选择 `Write`：只禁止后续写入，保留读取能力，用于“写完即止、等待对端确认”。
/// 2. 选择 `Read`：停止读取但仍允许写入，适合“发送剩余数据、忽略对端输出”。
/// 3. 选择 `Both`：一次性关闭读写方向，实现完全终止。
///
/// ### 风险提示（R4.2）
/// - 某些协议的半关闭会在对端触发 EOF；若业务需要保持长连接心跳，应避免误用 `Both`。
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ShutdownDirection {
    /// 关闭写方向，后续写入将被拒绝或直接返回 EOF。
    Write,
    /// 关闭读方向，后续读取将立即返回 EOF。
    Read,
    /// 同时关闭读写方向，等价于完全终止连接。
    Both,
}
