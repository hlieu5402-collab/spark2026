#![cfg_attr(not(feature = "std"), no_std)]
#![warn(missing_docs)]

//! # spark-codec-rtp
//!
//! ## 教案目的（Why）
//! - **定位**：Real-time Transport Protocol (RTP) 数据面编解码骨架，负责媒体帧的封包/拆包。
//! - **架构角色**：在整体语音/视频栈中，RTP 紧随 SDP 协商之后运行，对媒体负载进行序列化并携带时序信息。
//! - **设计策略**：通过占位实现将 crate 納入 workspace，确保 `spark-impl-tck` 能够引用并预置后续的包格式校验。
//!
//! ## 交互契约（What）
//! - **依赖输入**：基于 `spark-core` 的 `Codec` trait，将处理来自网络的数据帧与上游编码器产生的 payload。
//! - **输出职责**：未来实现中会生成 `RtpPacket` 结构并处理扩展 header、重传标记等；当前仅提供占位结构。
//! - **前置条件**：假设调用环境具备高精度计时与缓冲池支持；占位阶段不涉及任何运行时副作用。
//!
//! ## 实现策略（How）
//! - **里程碑**：
//!   1. 引入 `RtpCodecScaffold` 保持 API 稳定；
//!   2. 在 TCK 中覆盖序列号回绕、时间戳漂移等测试用例；
//!   3. 集成 `spark-core` 的零拷贝缓冲，实现性能友好的打包逻辑。
//! - **技术细节**：使用零尺寸结构降低编译成本，并通过特性位保持 no_std 兼容。
//!
//! ## 风险提示（Trade-offs）
//! - **功能缺口**：暂未实现实际的 RTP 编解码流程，无法直接处理媒体数据。
//! - **性能考量**：未来需重点关注 jitter buffer、包丢失补偿等场景。
//! - **维护提醒**：扩展 header 解析往往涉及位运算，务必在 TCK 中加入边界测试。

/// RTP 编解码占位结构，明确媒体数据通道的实现入口。
///
/// ### 设计意图（Why）
/// - 提前固定类型名称，方便调用方和测试桩引用。
/// - 与 SIP/SDP 协同，构成端到端媒体处理流水线。
///
/// ### 契约说明（What）
/// - 当前不存储任何字段，仅提供语义占位。
/// - 未来将扩展 payload type、序列号、时间戳等状态。
///
/// ### 实现策略（How）
/// - 通过 `Default`/`Copy` 简化测试构造。
/// - 若未来需要持有缓冲区，需重新评估内存管理策略。
///
/// ### 风险提示（Trade-offs）
/// - 当添加状态后，应确保线程安全语义满足调用方需求。
#[derive(Debug, Default, Clone, Copy)]
pub struct RtpCodecScaffold;

impl RtpCodecScaffold {
    /// 构造 RTP 编解码占位实例。
    ///
    /// ### 设计动机（Why）
    /// - 为 `spark-impl-tck` 提供稳定的类型依赖，便于提前编写测试脚本。
    /// - 对外暴露统一的构造入口，方便未来扩展参数。
    ///
    /// ### 契约定义（What）
    /// - **输入**：无。
    /// - **输出**：`RtpCodecScaffold` 的零尺寸实例。
    /// - **前置条件**：调用方只需链接本 crate 即可，无额外资源需求。
    /// - **后置条件**：获得一个可复制的占位类型，可用于泛型约束或测试桩。
    ///
    /// ### 实现说明（How）
    /// - `const fn` 允许在编译期常量上下文中使用（例如默认配置）。
    ///
    /// ### 风险提示（Trade-offs）
    /// - 随着功能完善可能需要返回 `Result` 表达错误；届时需同步更新所有调用方。
    #[must_use]
    pub const fn new() -> Self {
        Self
    }
}
