#![cfg_attr(not(feature = "std"), no_std)]
#![warn(missing_docs)]

//! # spark-codec-sip
//!
//! ## 教案目的（Why）
//! - **定位**：该 crate 作为 Session Initiation Protocol (SIP) 编解码器的骨架，验证 `spark-core` Codec 扩展点的 VoIP 场景适配能力。
//! - **架构角色**：在整体平台中，本模块将负责从 SIP 报文中提取信令字段、驱动呼叫状态机，是后续媒体协商模块（SDP/ RTP）的入口。
//! - **设计思路**：通过提供占位实现，提前建立 workspace 结构与依赖关系，确保后续增量开发可以直接聚焦业务逻辑。
//!
//! ## 交互契约（What）
//! - **依赖输入**：所有业务逻辑都将依赖 `spark-core` 暴露的 `Codec`、`DecodeContext` 等 trait；占位版本尚未导出具体实现。
//! - **预期输出**：未来会对外暴露 `SipCodec` 类型，负责解析/构建 SIP 报文；当前仅提供占位结构，保证 API 入口稳定。
//! - **前置约束**：调用侧需在 Tokio 或等价异步运行时中运行，并提供 UTF-8 文本缓冲；当前阶段仅编译占位类型，不参与运行时路径。
//!
//! ## 实现策略（How）
//! - **分步路线**：
//!   1. 以 `SipCodecScaffold` 作为零成本占位，维持 future-proof API 形态；
//!   2. 后续迭代将补齐解析/编码管线，并在 `spark-impl-tck` 中落地兼容性测试；
//!   3. 结合 `spark-core` 的错误模型，实现基于状态码的诊断。
//! - **技术要点**：占位实现仅包含构造函数，避免无意义的逻辑分支，同时保留 `#[must_use]` 提示使用者显式处理实例。
//! - **扩展考虑**：文档中已预留 `compat_v0` 等特性位，方便未来与旧版协议保持兼容。
//!
//! ## 风险提示（Trade-offs）
//! - **功能缺口**：当前缺少实际的字节处理逻辑，无法直接运行 SIP 会话；重点确保依赖关系与命名一致。
//! - **边界情形**：未来需要关注长报文、分片传输、header 折行等 SIP 特性，此处暂未覆盖。
//! - **维护提示**：任何新增 API 均应同步更新 `spark-impl-tck` 的测试用例，避免接口漂移。

/// SIP 编解码骨架类型，后续将扩展为完整的 Codec 实现。
///
/// ### 设计意图（Why）
/// - 通过预留公开结构体，向调用方和测试框架表明未来的主要交互入口。
/// - 该类型对应 SIP 协议中的信令通道，与 SDP/ RTP 模块协同完成会话建立。
///
/// ### 交互契约（What）
/// - `SipCodecScaffold` 当前不暴露字段，也不携带状态，仅用于保持 API 稳定。
/// - 后续演进将新增配置字段（如事务超时、最大报文长度）。
///
/// ### 实现笔记（How）
/// - 采用零尺寸类型（ZST）降低占位成本；通过 `Default` 与 `Copy` trait 便于测试快速实例化。
///
/// ### 风险提示（Trade-offs）
/// - 若未来需要持有大量配置，应重新评估 `Copy`/`Default` 的语义是否仍然成立。
#[derive(Debug, Default, Clone, Copy)]
pub struct SipCodecScaffold;

impl SipCodecScaffold {
    /// 创建一个新的 SIP 编解码占位实例。
    ///
    /// ### 设计动机（Why）
    /// - 为上层调用提供稳定的构造入口，确保后续增加参数时依旧保持向后兼容。
    /// - 便于 `spark-impl-tck` 在测试中快速生成占位实例。
    ///
    /// ### 调用契约（What）
    /// - **输入参数**：无。调用方无需提供额外状态或配置。
    /// - **返回值**：返回零尺寸的 `SipCodecScaffold`，表示一个可用的占位实例。
    ///
    /// ### 使用指南（How）
    /// - 当前阶段仅作为标记对象，可用于编译期验证依赖关系。
    /// - 后续新增参数时建议采用构建器模式，以保持调用语义清晰。
    ///
    /// ### 注意事项（Trade-offs）
    /// - 方法标注 `#[must_use]`，提醒调用方未来可能需要处理初始化结果。
    /// - 若未来构造过程涉及校验或 I/O，需要补充错误返回类型。
    #[must_use]
    pub const fn new() -> Self {
        Self
    }
}
